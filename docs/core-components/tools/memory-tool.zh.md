# 记忆工具

让 Agent 拥有持久记忆,记住您的偏好、从经验中学习,并在多次对话中提供个性化服务。

## 为什么使用记忆工具

- 跨对话持续服务
- 个性化响应符合您的风格
- Agent 从积累的经验中改进
- 基于历史的上下文感知决策

**核心机制:**

1. **用户记忆:** 您定义偏好、约束
2. **Agent 记忆:** Agent 记录自己的执行模式和见解
3. **分类:** 两者都按主题组织记忆
4. **智能搜索:** Agent 在执行任务前独立探索记忆

### 记忆生命周期

每条记忆都有完整的生命周期跟踪:

| 字段 | 用途 |
|------|------|
| **ID** | 唯一标识符(格式:`YYYYMMDD_xxxx`) |
| **内容** | 实际记忆文本(建议 ≤300 字) |
| **创建时间** | 条目添加时间 |
| **更新时间** | 最后修改时间戳(变更时自动更新) |

## 记忆操作

### 列出分类

发现存在哪些记忆:
- 查询用户记忆、Agent 记忆或两者
- 返回分类名称和条目数
- 帮助 Agent 了解可用知识

### 获取记忆

检索特定记忆:
- 一次从多个分类获取
- 跨所有者查询(如:用户 `code_style` + Agent `learned_patterns`)
- 结果按最近更新排序

### 添加记忆

存储新知识:
- 一次调用跨分类添加多个条目
- 分类不存在时自动创建
- 记录创建时间戳

### 更新记忆

完善现有记忆:
- 通过 ID 修改特定条目
- 自动更新 `updated_at` 时间戳
- 适用于演变的偏好

### 删除记忆

移除过时信息:
- 通过 ID 删除特定条目
- 跨分类批量删除
- 保持记忆相关和准确

### 智能搜索

AI 驱动的记忆探索:
- Agent 描述要查找的内容
- 搜索在隔离子任务中运行
- 返回相关记忆的组织化摘要
- 无主对话 token 开销

## 集成模式

### 记忆 + 子 Agent

专家继承或共享记忆:

**共享用户记忆:**
对话中所有 Agent 访问相同用户偏好(行为一致)

**独立 Agent 记忆:**
每个专家从其领域学习(代码审查者 vs. 写作者有不同见解)

**交接模式:**
主 Agent 搜索记忆 → 带上下文委派给专家 → 专家从执行中学习 → 更新自己的记忆

### 记忆 + 文件工具

结合持久知识与文档交付:

**记忆指导行为:** Agent 读取 `documentation` 偏好
**文件工具交付结果:** 创建遵循这些偏好的 `api_docs.md`
**学习循环:** 用户批准后,Agent 在记忆中记录成功模式

## 配置要求

有效使用记忆的要求:

| 要求 | 目的 |
|------|------|
| **明确指令** | 告诉 Agent 何时查阅记忆(如:"代码生成前始终检查用户偏好") |
| **记忆访问** | 在 Agent 配置中启用记忆工具 |
| **智能搜索使用** | 鼓励在复杂任务前使用 |
| **学习提示** | 指示 Agent 记录成功策略 |


## 相关文档

- [用户记忆](../memory/long-term/user-memory.zh.md) - 用户记忆
- [Agent 记忆](../memory/long-term/agent-memory.zh.md) - Agent 记忆
- [Agent 配置](../agent/config.zh.md) - 在 Agent 中启用记忆工具
